/********************************************************************************/
/*************** Copyright (C) 2006-2011 Bertin Technologies, SAS  **************/
/*			  				      	TranscriberAG	 							*/
/* 	         																	*/
/* See COPYING for license information										  	*/
/* 	         																	*/
/********************************************************************************/

#include <iterator>
#include <algorithm>
#include <set>
#include <vector>
#include <ag/AGAPI.h>
#include <libgen.h>

#include "TXTWriter.h"
#include "Common/VersionInfo.h"
#include "Common/util/Utils.h"
#include "Common/util/StringOps.h"
#include "Common/util/FormatTime.h"
#include "DataModel/speakers/Speaker.h"
#include "DataModel/speakers/SpeakerDictionary.h"
#include <glib.h>

using namespace tag;

class SortIdsByOffset : public binary_function < const string&, const string&, bool >
{
    private :
        tag::DataModel* m_data;
    public:
        SortIdsByOffset(tag::DataModel* data) : m_data(data) {}
        bool operator() (const string& id1, const string& id2) {
        	return m_data->getElementOffset(id1,true) < m_data->getElementOffset(id2, true);
        }
};

string TXTWriter::header()
{
	return "# Generated by TranscriberAG\n" ;
}

string TXTWriter::trailer()
{
	return "\n";
}

string TXTWriter::noSpeaker()
{
	return "** " + string(_("(No speaker)")) + " **";
}


string TXTWriter::section_beg() {
	return "\t\t\t\t\t[ ";
}

string TXTWriter::section_end() {
	return " ]\n" ;
}

string TXTWriter::speaker_beg(Speaker::Gender gender) {
	return "** " ;
}

string TXTWriter::speaker_end() {
	return " **\n";
}



int TXTWriter::write(ostream& out, DataModel* data)
{
	m_data = data;
	m_graphtype = "transcription_graph";
	m_graphId = m_data->getAG(m_graphtype);
	const vector<string>& mainstream_types = m_data->getMainstreamTypes(m_graphtype);


	// Ecriture du header
	out << header() << endl;

	// Ecriture des propriétés du tag dans un tableau
	const std::map<string, string>& items = m_data->getAGSetProperties();
	std::map<string, string>::const_iterator it;


	// NOMBRE DE PISTE
	int nb_tracks = m_data->getNbTracks();
	out << "# Nombre de Pistes : " << nb_tracks << endl;

	// DUREE
	out << "# Durée :" << FormatTime(m_data->getSignalDuration(), true, true)  << endl ;

	// NB DE SPEAKER
	out << "# Nombre de locuteurs : " << m_data->getSpeakerDictionary().size()  << endl;


	for (it= items.begin(); it != items.end(); ++it)
	{
		// LANGUE DU TEXTE
		if (it->first == "lang") {
			out << "# Langue : " << it->second  << endl;
		}
	}

	int itype = 0;

	if ( nb_tracks == 1 )
	{
		//MONO
		for ( itype=0;
				itype < mainstream_types.size() && ! m_data->hasElementsWithType(mainstream_types[itype], m_graphId);
				++itype);  // eventually skip missing top levels
		if ( itype < mainstream_types.size() )
			renderAll(out, mainstream_types, itype, "", 0);
		else
			out << "<br/> NO ELEMENT TO PRINT !! <br/>" << endl;
	}
	else
	{
		//STEREO -> don't render eventual sections, and interlace turns

		for ( itype=0; itype < mainstream_types.size() && mainstream_types[itype] != "turn" ;++itype );
		if ( itype < mainstream_types.size() ) {
			renderAll(out, mainstream_types, itype, "", -1);
		}
	}

	out << trailer() << endl;
	return 0;
}

void TXTWriter::renderAll(ostream& out, const vector<string>& mainstream_types, int itype, const string& parent, int notrack)
{
	const string& curtype = mainstream_types[itype];
	bool render_next_level = (itype+1) < mainstream_types.size() ;
	vector<string> childs;

	int renderer = 0;
	if ( curtype == "section") renderer = 1;
	else if ( curtype == "turn" ) renderer = 2;
	else if (curtype == "segment" ) renderer = 3;


	//> -- Rendering all mainstreams except mainstream base type
	if ( curtype != m_data->mainstreamBaseType(m_graphtype) )
	{
		if ( notrack == -1 ) {
			m_data->getChilds(childs, curtype, parent, 0);
			int i;
			for (i=1; i < m_data->getNbTracks(); ++i ) {
				vector<string> childs2;
				m_data->getChilds(childs2, curtype, parent, i);
				copy(childs2.begin(), childs2.end(), back_inserter(childs));
			}

			SortIdsByOffset cmp(m_data);
			sort(childs.begin(), childs.end(), cmp);
		}
		else
			m_data->getChilds(childs, curtype, parent, notrack);

		vector<string>::iterator itc;
		for ( itc = childs.begin(); itc != childs.end(); ++itc )
		{
			switch (renderer) {
			case 1:		renderSectionStart(out, *itc); break;
			case 2:		renderTurnStart(out, *itc); break;
			case 3:		renderSegmentStart(out, *itc); break;
			default: 	out << "##  No renderer for type " << curtype << " ##" << endl; break;
			}

			if ( render_next_level )
			{
				if ( notrack == -1 && !parent.empty() )
					notrack = m_data->getElementSignalTrack(parent);
				renderAll(out, mainstream_types, itype+1, *itc, m_data->getElementSignalTrack(*itc));
			}
			switch (renderer) {
			case 1:		renderSectionEnd(out, *itc); break;
			case 2:		renderTurnEnd(out, *itc); break;
			case 3:		renderSegmentEnd(out, *itc); break;
			}
		}
	}
	//> -- Rendering mainstream base type
	else
	{
		m_data->getChilds(childs, curtype, parent, notrack);
		vector<string>::iterator itc;
		bool first = true;
		for ( itc = childs.begin(); itc != childs.end(); ++itc )
		{
			if ( m_printDetailed ) {
				out << endl << "  ";
//				if ( ! first ) out << " / " ;
			}
			renderBaseElement(out, *itc);
			first = false;
		}
	}
}

void TXTWriter::renderSectionStart(ostream& out, const string& id)
{
	const string& sectTopicID = m_data->getElementProperty(id, "topic");
	const string& sectDesc = m_data->getElementProperty(id, "desc");

	if ( m_printDetailed )
		out << "/section id=" << id << "/ ";
	out << endl << endl << section_beg() << m_data->getElementProperty(id, "type")	;
	if (sectDesc != "")
		out << " - " << sectDesc;

	if (sectTopicID != "")
	{
		Topic* topic =  Topics::getTopicFromAll(sectTopicID, m_data->conventions().getTopics());
		out << " {" << topic->getLabel() << "} ";
	}

	out << section_end() << endl;
}

void TXTWriter::renderSectionEnd(ostream& out, const string& id)
{
}

void TXTWriter::renderTurnStart(ostream& out, const string& id)
{
	const string& spkid = m_data->getElementProperty(id, "speaker");
	string spkname= spkid;
	Speaker::Gender gender = Speaker::UNDEF_GENDER;
	try
	{
		const Speaker& spk=m_data->getSpeakerDictionary().getSpeaker(spkid);
		spkname = spk.getFullName();
		gender=spk.getGender();
	}
	catch(...) {}

	if ( m_printDetailed )
		out << "/turn id=" << id << "/ ";

	if( (spkid == "") || ( spkid == tag::Speaker::NO_SPEECH))
		out << noSpeaker() ;
	else {
		if ( m_data->getOrder(id) > 0 )
			out << endl << "\t" << endl ;
		out << speaker_beg(gender) << spkname << speaker_end() <<" ";
	}
}

void TXTWriter::renderTurnEnd(ostream& out, const string& id)
{
	out << endl;
}

void TXTWriter::renderSegmentStart(ostream& out, const string& id)
{
	if ( m_data->getOrder(id) > 0 || m_data->getElementSignalTrack(id) > 0 )
		out << "\t" ;

	if ( m_printDetailed )
		out << "/segment id=" << id << "/ ";
	out << " - ";

		if (m_printTimeCode && ! m_printDetailed ) {
			out << "{" << m_data->getStartOffset(id) << "} ";
		}
}

void TXTWriter::renderSegmentEnd(ostream& out, const string& id)
{
		out << endl;
}

void TXTWriter::renderBaseElement(ostream& out, const string& id)
{
	bool text_type = (m_data->getElementProperty(id, "subtype") == "unit_text");
	const string& value = m_data->getElementProperty(id, "value");

	if ( m_printDetailed &&  m_data->isAnchoredElement(id, 0)  ) {
		out << "{" << m_data->getElementOffset(id, true) << " - " << id << "} ";
	}

	if ( text_type ) 	{
		renderQualifiersAtStart(out, id, value.empty());
		out <<  value  << " ";
		renderQualifiersAtEnd(out, id, value.empty());
	} else {
		renderQualifiersAtStart(out, id, false);
		const string& desc = m_data->getElementProperty(id, "desc");
		out << "{" << value;
		if ( !desc.empty() ) out << "=" << desc;
		out << "} ";
		renderQualifiersAtEnd(out, id, value.empty());
	}
}

void TXTWriter::renderQualifiersAtStart(ostream& out, const string& id, bool no_text)
{
	vector<string> ids;
	vector<string>::iterator it;

	m_data->getQualifiers(id, ids, "", true, false);
	for ( it=ids.begin(); it != ids.end(); ++it )
	{
		const string& qtype = m_data->getElementType(*it);
		const string& desc = m_data->getElementProperty(*it, "desc");
		bool instantaneous = (m_data->isInstantaneous(*it) || no_text);

		out << "[" << qtype;
		if (!desc.empty()) out << "=" << desc;
		if ( !instantaneous ) out << " -] ";
		else out << "] ";
	}
}

void TXTWriter::renderQualifiersAtEnd(ostream& out, const string& id, bool no_text)
{
	vector<string> ids;
	vector<string>::iterator it;

	m_data->getQualifiers(id, ids, "", true, false);
	for ( it=ids.begin(); it != ids.end(); ++it )
	{
		const string& qtype = m_data->getElementType(*it);
		const string& desc = m_data->getElementProperty(*it, "desc");
		bool instantaneous = (m_data->isInstantaneous(*it) || no_text);

		if ( !instantaneous ) {
			out << "[-" << qtype ;
			if (!desc.empty()) out << "=" << desc;
			out << "] ";
		}
	}
}
