/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.19
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    inline SwigValueWrapper() : tt(0) { }
    inline ~SwigValueWrapper() { if (tt) delete tt; } 
    inline SwigValueWrapper& operator=(const T& t) { tt = new T(t); return *this; }
    inline operator T&() const { return *tt; }
    inline T *operator&() { return tt; }
};                                                    
#endif

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;	
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;	
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;  /**/
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;  /**/
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/*
 * $Header: /cvsroot/agtk/AGLIB/src/ag_wrapper/tcl/ag.cc,v 1.7.4.6 2003/05/12 13:14:53 haepal Exp $
 * 
 * swigtcl8.swg
 */

#include <tcl.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Constant table */

#define SWIG_TCL_INT     1
#define SWIG_TCL_FLOAT   2
#define SWIG_TCL_STRING  3
#define SWIG_TCL_POINTER 4
#define SWIG_TCL_BINARY  5

/* Flags for pointer conversion */
#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Swig fail macro */

#define SWIG_fail   goto fail
   
/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
typedef void  (*swig_delete_func)(ClientData);

typedef struct swig_method { 
  const char     *name;
  swig_wrapper   method;
} swig_method;

typedef struct swig_attribute {
  const char     *name;
  swig_wrapper   getmethod;
  swig_wrapper   setmethod;
} swig_attribute;
  
typedef struct swig_class {
  const char         *name;
  swig_type_info   **type;
  swig_wrapper       constructor;
  void              (*destructor)(void *);
  swig_method        *methods;
  swig_attribute     *attributes;
  struct swig_class **bases;
} swig_class;

typedef struct swig_instance {
  Tcl_Obj       *thisptr;
  void          *thisvalue;
  swig_class   *classptr;
  int            destroy;
  Tcl_Command    cmdtok;
} swig_instance;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(char *)    SWIG_PackData(char *c, void *ptr, int sz);
SWIGEXPORT(char *)    SWIG_UnpackData(char *c, void *ptr, int sz);
SWIGEXPORT(int)       SWIG_ConvertPtrFromString(Tcl_Interp *, char *, void **, swig_type_info *,int flags);
SWIGEXPORT(int)       SWIG_ConvertPtr(Tcl_Interp *, Tcl_Obj *, void **, swig_type_info *, int flags);
SWIGEXPORT(int)       SWIG_ConvertPacked(Tcl_Interp *, Tcl_Obj *, void *, int sz, swig_type_info *, int flags);
SWIGEXPORT(void)      SWIG_MakePtr(char *, void *, swig_type_info *, int flags);
SWIGEXPORT(Tcl_Obj *) SWIG_NewPointerObj(void *, swig_type_info *, int flags);
SWIGEXPORT(Tcl_Obj *) SWIG_NewPackedObj(void *, int sz, swig_type_info *, int flags);
SWIGEXPORT(int)       SWIG_GetArgs(Tcl_Interp *, int, Tcl_Obj *CONST [], const char *, ...);
SWIGEXPORT(char *)    SWIG_PointerTypeFromString(char *c);
SWIGEXPORT(void)      SWIG_Acquire(void *ptr);
SWIGEXPORT(int)       SWIG_Disown(void *ptr);
SWIGEXPORT(int)       SWIG_Thisown(void *ptr);
SWIGEXPORT(void)      SWIG_InstallConstants(Tcl_Interp *interp, struct swig_const_info constants[]);
SWIGEXPORT(Tcl_Obj *) SWIG_GetConstant(const char *key);
SWIGEXPORT(Tcl_Obj *) SWIG_NewInstanceObj(Tcl_Interp *interp, void *, swig_type_info *, int flags);
SWIGEXPORT(int)       SWIG_ObjectConstructor(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST objv[]);
SWIGEXPORT(int)       SWIG_MethodCommand(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST objv[]);
SWIGEXPORT(void)      SWIG_ObjectDelete(ClientData);
#else

/* Object support */
static Tcl_HashTable  swigobjectTable;
static int            swigobjectTableinit = 0;

/* Acquire ownership of a pointer */
SWIGRUNTIME(void)
SWIG_Acquire(void *ptr)
{
  Tcl_HashEntry *entryPtr;
  int newobj;
  if (!swigobjectTableinit) {
    Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
    swigobjectTableinit = 1;
  }
  entryPtr = Tcl_CreateHashEntry(&swigobjectTable, (char *) ptr, &newobj);
}

/* Disown a pointer.  Returns 1 if we owned it to begin with */
SWIGRUNTIME(int)
SWIG_Disown(void *ptr)
{
  Tcl_HashEntry *entryPtr;
  if (!swigobjectTableinit) return 0;
  entryPtr = Tcl_FindHashEntry(&swigobjectTable, (char *) ptr);
  if (entryPtr) {
    Tcl_DeleteHashEntry(entryPtr);
    return 1;
  } 
  return 0;
}

SWIGRUNTIME(int)
SWIG_Thisown(void *ptr) {
  if (!swigobjectTableinit) return 0;
  if (Tcl_FindHashEntry(&swigobjectTable, (char *) ptr)) {
    return 1;
  }
  return 0;
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  if ((int)strlen(c) < (2*sz)) return c;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtrFromString(Tcl_Interp *interp, char *c, void **ptr, swig_type_info *ty, int flags)
{
  swig_type_info *tc;
  /* Pointer values must start with leading underscore */
  while (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) return TCL_OK;
    /* Hmmm. It could be an object name. */
    if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) == TCL_OK) {
      Tcl_Obj *result = Tcl_GetObjResult(interp);
      c = Tcl_GetStringFromObj(result, NULL);
      continue;
    }
    if (flags & SWIG_POINTER_EXCEPTION) 
      Tcl_SetResult(interp, (char *) "Type error. Expected a pointer", TCL_STATIC);
    return TCL_ERROR;
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if ((!tc) && (flags & SWIG_POINTER_EXCEPTION)) {
      Tcl_SetResult(interp, (char *) "Type error. Expected ", TCL_STATIC);
      Tcl_AppendElement(interp, (char *) ty->name);
      return TCL_ERROR;
    } else if (!tc) {
      return TCL_ERROR;
    }
    if (flags & SWIG_POINTER_DISOWN) {
      SWIG_Disown((void *) *ptr);
    }
    *ptr = SWIG_TypeCast(tc,(void *) *ptr);
  }
  return TCL_OK;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags)
{
  return SWIG_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty, flags);
}

/* Convert a pointer value */
SWIGRUNTIME(char *)
SWIG_PointerTypeFromString(char *c) {
  char d;
  /* Pointer values must start with leading underscore. NULL has no type */
  if (*c != '_') {
    return 0;
  }
  c++;
  /* Extract hex value from pointer */
  while ((d = *c)) {
    if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
    c++;
  }
  return c;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_ConvertPacked(Tcl_Interp *interp, Tcl_Obj *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;
  
  if (!obj) goto type_error;
  c = Tcl_GetStringFromObj(obj,NULL);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return TCL_OK;

type_error:

  if (flags) {
    if (ty) {
      Tcl_SetResult(interp, (char *) "Type error. Expected ", TCL_STATIC);
      Tcl_AppendElement(interp, (char *) ty->name);
      return TCL_ERROR;
    } else {
      Tcl_SetResult(interp, (char *) "Expected packed data.", TCL_STATIC);
      return TCL_ERROR;
    }
  }
  return TCL_ERROR;
}


/* Take a pointer and convert it to a string */
SWIGRUNTIME(void) 
SWIG_MakePtr(char *c, void *ptr, swig_type_info *ty, int flags) {
  if (ptr) {
    *(c++) = '_';
    c = SWIG_PackData(c,&ptr,sizeof(void *));
    strcpy(c,ty->name);
  } else {
    strcpy(c,(char *)"NULL");
  }
  flags = 0;
}

/* Create a new pointer object */
SWIGRUNTIME(Tcl_Obj *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  Tcl_Obj *robj;
  char result[512];
  SWIG_MakePtr(result,ptr,type,flags);
  robj = Tcl_NewStringObj(result,-1);
  return robj;
}

SWIGRUNTIME(Tcl_Obj *)
SWIG_NewPackedObj(void *ptr, int sz, swig_type_info *type, int flags) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  flags = 0;
  return Tcl_NewStringObj(result,-1);
}

static Tcl_HashTable   swigconstTable;
static int             swigconstTableinit = 0;

/* Install Constants */
SWIGRUNTIME(void)
SWIG_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
  int i;
  Tcl_Obj *obj;
  Tcl_HashEntry *entryPtr;
  int            newobj;

  if (!swigconstTableinit) {
    Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
    swigconstTableinit = 1;
  }
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_TCL_INT:
      obj = Tcl_NewIntObj(constants[i].lvalue);
      break;
    case SWIG_TCL_FLOAT:
      obj = Tcl_NewDoubleObj(constants[i].dvalue);
      break;
    case SWIG_TCL_STRING:
      obj = Tcl_NewStringObj((char *) constants[i].pvalue,-1);
      break;
    case SWIG_TCL_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_TCL_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype),0);
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      Tcl_ObjSetVar2(interp,Tcl_NewStringObj(constants[i].name,-1), NULL, obj, TCL_GLOBAL_ONLY);
      entryPtr = Tcl_CreateHashEntry(&swigconstTable, constants[i].name, &newobj);
      Tcl_SetHashValue(entryPtr, (ClientData) obj);
    }
  }
}

SWIGRUNTIME(Tcl_Obj *)
SWIG_GetConstant(const char *key) {
  Tcl_HashEntry *entryPtr;
  if (!swigconstTableinit) return 0;
  entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
  if (entryPtr) {
    return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
  }
  printf("Searching %s\n", key);
  return 0;
}

/* Get arguments */
SWIGRUNTIME(int)
SWIG_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...)
{
  int        argno = 0, opt = 0, tempi;
  double     tempd;
  const char *c;
  va_list    ap;
  void      *vptr;
  Tcl_Obj   *obj = 0;
  swig_type_info *ty;

  va_start(ap,fmt);
  for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
    if (*c == '|') {
      opt = 1;
      c++;
    }
    if (argno >= (objc-1)) {
      if (!opt) {
	Tcl_SetResult(interp, (char *) "Wrong # args. ", TCL_STATIC);
	goto argerror;
      } else {
	va_end(ap);
	return TCL_OK;
      }
    }

    vptr = va_arg(ap,void *);
    if (vptr) {
      if (isupper(*c)) {
	obj = SWIG_GetConstant(Tcl_GetStringFromObj(objv[argno+1],0));
	if (!obj) obj = objv[argno+1];
      } else {
	obj = objv[argno+1];
      }
      switch(*c) {
      case 'i': case 'I':
      case 'l': case 'L':
      case 'h': case 'H':
      case 'b': case 'B':
	if (Tcl_GetIntFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
	if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = tempi;
	else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = tempi;
	else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = tempi;
	else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = tempi;
	break;
      case 'f': case 'F':
      case 'd': case 'D':
	if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
	if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
	else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
	break;
      case 's': case 'S':
	if (*(c+1) == '#') {
	  int *vlptr = (int *) va_arg(ap, void *);
	  *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
	  c++;
	} else {
	  *((char **)vptr) = Tcl_GetStringFromObj(obj,NULL);
	}
	break;
      case 'c': case 'C':
	*((char *)vptr) = *(Tcl_GetStringFromObj(obj,NULL));
	break;
      case 'p': case 'P':
	ty = (swig_type_info *) va_arg(ap, void *);
	if (SWIG_ConvertPtr(interp, obj, (void **) vptr, ty, SWIG_POINTER_EXCEPTION) == TCL_ERROR) goto argerror;
	break;
      case 'o': case 'O':
	*((Tcl_Obj **)vptr) = objv[argno+1];
	break;
      default:
	break;
      }
    }
  }
  
  if ((*c != ';') && ((objc-1) > argno)) {
    Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
    goto argerror;
  }
  va_end(ap);
  return TCL_OK;
  
 argerror:
  {
    char temp[32];
    sprintf(temp,"%d", argno+1);
    c = strchr(fmt,':');
    if (!c) c = strchr(fmt,';');
    if (!c) c = (char *)"";
    Tcl_AppendResult(interp,c," argument ", temp, NULL);
    va_end(ap);
    return TCL_ERROR;
  }
}

SWIGRUNTIME(void)
SWIG_ObjectDelete(ClientData clientData) {
  swig_instance *si = (swig_instance *) clientData;
  if ((si) && (si->destroy) && (SWIG_Disown(si->thisvalue))) {
    if (si->classptr->destructor) {
      (si->classptr->destructor)(si->thisvalue);
    }
  }
  Tcl_DecrRefCount(si->thisptr);
  free(si);
}

/* Function to invoke object methods given an instance */
SWIGRUNTIME(int)
SWIG_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[])
{
  char *method,   *attrname;
  swig_instance   *inst = (swig_instance *) clientData;
  swig_method     *meth;
  swig_attribute  *attr;
  Tcl_Obj         *oldarg;
  Tcl_Obj         **objv;
  int              rcode;
  swig_class      *cls;
  swig_class      *cls_stack[64];
  int              cls_stack_bi[64];
  int              cls_stack_top = 0;
  int              numconf = 2;
  int              bi;

  objv = (Tcl_Obj **) _objv;
  if (objc < 2) {
    Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
    return TCL_ERROR;
  }
  method = Tcl_GetStringFromObj(objv[1],NULL);
  if (strcmp(method,"-acquire") == 0) {
    inst->destroy = 1;
    SWIG_Acquire(inst->thisvalue);
    return TCL_OK;
  } 
  if (strcmp(method,"-disown") == 0) {
    if (inst->destroy) {
      SWIG_Disown(inst->thisvalue);
    }
    inst->destroy = 0;
    return TCL_OK;
  }
  if (strcmp(method,"-delete") == 0) {
    Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
    return TCL_OK;
  }
  cls_stack[cls_stack_top] = inst->classptr;
  cls_stack_bi[cls_stack_top] = -1;
  cls = inst->classptr;
  while (1) {
    bi = cls_stack_bi[cls_stack_top];
    cls = cls_stack[cls_stack_top];
    if (bi != -1) {
      cls = cls->bases[bi];
      if (cls) {
	cls_stack_bi[cls_stack_top]++;
	cls_stack_top++;
	cls_stack[cls_stack_top] = cls;
	cls_stack_bi[cls_stack_top] = -1;
	continue;
      }
    }
    if (!cls) {
      cls_stack_top--;
      if (cls_stack_top < 0) break;
      else continue;
    }
    cls_stack_bi[cls_stack_top]++;

    meth = cls->methods;
    /* Check for methods */
    while (meth && meth->name) {
      if (strcmp(meth->name,method) == 0) {
	oldarg = objv[1];
	objv[1] = inst->thisptr;
	Tcl_IncrRefCount(inst->thisptr);
	rcode = (*meth->method)(clientData,interp,objc,objv);
	objv[1] = oldarg;
	Tcl_DecrRefCount(inst->thisptr);
	return rcode;
      }
      meth++;
    }
    /* Check class methods for a match */
    if (strcmp(method,"cget") == 0) {
      if (objc < 3) {
	Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
	return TCL_ERROR;
      }
      attrname = Tcl_GetStringFromObj(objv[2],NULL);
      attr = cls->attributes;
      while (attr && attr->name) {
	if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
	  oldarg = objv[1];
	  objv[1] = inst->thisptr;
	  Tcl_IncrRefCount(inst->thisptr);
	  rcode = (*attr->getmethod)(clientData,interp,2, objv);
	  objv[1] = oldarg;
	  Tcl_DecrRefCount(inst->thisptr);
	  return rcode;
	}
	attr++;
      }
      if (strcmp(attrname, "-this") == 0) {
	Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
	return TCL_OK;
      }
      if (strcmp(attrname, "-thisown") == 0) {
	if (SWIG_Thisown(inst->thisvalue)) {
	  Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
	} else {
	  Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
	}
	return TCL_OK;
      }
    } else if (strcmp(method, "configure") == 0) {
      int i;
      if (objc < 4) {
	Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
	return TCL_ERROR;
      }
      i = 2;
      while (i < objc) {
	attrname = Tcl_GetStringFromObj(objv[i],NULL);
	attr = cls->attributes;
	while (attr && attr->name) {
	  if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
	    oldarg = objv[i];
	    objv[i] = inst->thisptr;
	    Tcl_IncrRefCount(inst->thisptr);
	    rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
	    objv[i] = oldarg;
	    Tcl_DecrRefCount(inst->thisptr);
	    if (rcode != TCL_OK) return rcode;
	    numconf += 2;
	  }
	  attr++;
	}
	i+=2;
      }
    }
  }
  if (strcmp(method,"configure") == 0) {
    if (numconf >= objc) {
      return TCL_OK;
    } else {
      Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
      return TCL_ERROR;
    }
  }
  if (strcmp(method,"cget") == 0) {
      Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
      return TCL_ERROR;
  }

  Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
  cls = inst->classptr;
  bi = 0;
  while (cls) {
    meth = cls->methods;
    while (meth && meth->name) {
      char *cr = (char *) Tcl_GetStringResult(interp);
      if (!strstr(strchr(cr,':'), meth->name))
	Tcl_AppendElement(interp, (char *) meth->name);
      meth++;
    }
    cls = inst->classptr->bases[bi++];
  }
  return TCL_ERROR;
}

/* Function to create objects */
SWIGRUNTIME(int)
SWIG_ObjectConstructor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    Tcl_Obj          *newObj = 0;
    void             *thisvalue = 0;
    swig_instance   *newinst = 0;
    swig_class      *classptr = (swig_class *) clientData;
    swig_wrapper     cons = 0;
    char             *name = 0;
    int               firstarg = 0;
    int               thisarg = 0;
    int               destroy = 1; 

    if (!classptr) {
      Tcl_SetResult(interp, (char *) "swig: internal runtime error. No class object defined.", TCL_STATIC);
      return TCL_ERROR;
    }
    cons = classptr->constructor;
    if (objc > 1) {
      char *s = Tcl_GetStringFromObj(objv[1],NULL);
      if (strcmp(s,"-this") == 0) {
	thisarg = 2;
	cons = 0;
      } else if (strcmp(s,"-args") == 0) {
	firstarg = 1;
      } else if (objc == 2) {
	firstarg = 1;
	name = s;
      } else if (objc >= 3) {
	char *s1;
	name = s;
	s1 = Tcl_GetStringFromObj(objv[2],NULL);
	if (strcmp(s1,"-this") == 0) {
	  thisarg = 3;
	  cons = 0;
	} else {
	  firstarg = 1;
	}
      }
    }
    if (cons) {
      int result;
      result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
      if (result != TCL_OK) {
	return result;
      }
      newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
      if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
    } else if (thisarg > 0) {
      if (thisarg < objc) {
	destroy = 0;
	newObj = Tcl_DuplicateObj(objv[thisarg]);
	if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
      } else {
	Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
	return TCL_ERROR;
      }
    } else {
      Tcl_SetResult(interp, (char *) "No constructor available.", TCL_STATIC);
      return TCL_ERROR;
    }
    if (SWIG_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type), SWIG_POINTER_EXCEPTION) == TCL_ERROR) {
      Tcl_DecrRefCount(newObj);
      return TCL_ERROR;
    }
    newinst = (swig_instance *) malloc(sizeof(swig_instance));
    newinst->thisptr = newObj;
    Tcl_IncrRefCount(newObj);
    newinst->thisvalue = thisvalue;
    newinst->classptr = classptr;
    newinst->destroy = destroy;
    if (destroy) {
      SWIG_Acquire(thisvalue);
    }
    newinst->cmdtok = Tcl_CreateObjCommand(interp,name, (swig_wrapper) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
    return TCL_OK;
}


/* This function takes the current result and turns it into an object command */
SWIGRUNTIME(Tcl_Obj *)
SWIG_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
  Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
  /* Check to see if this pointer belongs to a class or not */
  if ((type->clientdata) && (interp)) {
    Tcl_CmdInfo    ci;
    char          *name;
    name = Tcl_GetStringFromObj(robj,NULL);
    if (!Tcl_GetCommandInfo(interp,name, &ci) || (flags)) {
      swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
      newinst->thisptr = Tcl_DuplicateObj(robj);
      Tcl_IncrRefCount(newinst->thisptr);
      newinst->thisvalue = thisvalue;
      newinst->classptr = (swig_class *) type->clientdata;
      newinst->destroy = flags;
      newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetStringFromObj(robj,NULL), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
      if (flags) {
	SWIG_Acquire(thisvalue);
      }
    }
  }
  return robj;
}

#endif

/* Structure for command table */
typedef struct {
  const char *name;
  int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
  ClientData  clientdata;
} swig_command_info;

/* Structure for variable linking table */
typedef struct {
  const char *name;
  void *addr;
  char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
  char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
} swig_var_info;

#ifdef __cplusplus
}
#endif






/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_mapTstring_string_t swig_types[0] 
#define  SWIGTYPE_p_setTstring_t swig_types[1] 
#define  SWIGTYPE_p_listTstring_t swig_types[2] 
#define  SWIGTYPE_p_string swig_types[3] 
static swig_type_info *swig_types[5];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Ag_Init
#define SWIG_name    "ag"
#define SWIG_prefix  "AG::"
#define SWIG_namespace "AG"

#define SWIG_version "2.0"


#ifdef __cplusplus
extern "C" {
#endif
#ifdef MAC_TCL
#pragma export on
#endif
SWIGEXPORT(int) SWIG_init(Tcl_Interp *);
#ifdef MAC_TCL
#pragma export off
#endif
#ifdef __cplusplus
}
#endif



#include <ag/AGAPI.h>
#include <ag/AGException.h>
#include <ag/agfio.h>


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


#define SWIG_exception(a,b)   { Tcl_SetResult(interp,b,TCL_VOLATILE); SWIG_fail; }


#define raise_error(msg) { \
        string message = "WrapperError\x01"; \
        message += msg; \
        SWIG_exception(SWIG_RuntimeError, (char*) message.c_str()); \
    }


void
tlist2list(Tcl_Interp* interp, Tcl_Obj* lst, list<string>& l)
{
    int num_elts;           // number of elemtnts
    Tcl_Obj** elts;         // list of elements
    if (Tcl_ListObjGetElements(interp,lst,&num_elts,&elts) ==
            TCL_ERROR) {
        Tcl_FreeResult(interp);
        throw string("failed to get list elements");
    }

    l.clear();
    for (int i=0; i < num_elts; ++i) {
        l.push_back(Tcl_GetString(elts[i]));
    }

    Tcl_FreeResult(interp);
}

void
tlist2set(Tcl_Interp* interp, Tcl_Obj* lst, set<string>& s)
{
    int num_elts;           // number of elemtnts
    Tcl_Obj** elts;         // list of elements
    if (Tcl_ListObjGetElements(interp,lst,&num_elts,&elts) ==
            TCL_ERROR) {
        Tcl_FreeResult(interp);
        throw string("failed to get list elements");
    }

    s.clear();
    for (int i=0; i < num_elts; ++i) {
        s.insert(Tcl_GetString(elts[i]));
    }

    Tcl_FreeResult(interp);
}

void
array2map(Tcl_Interp* interp, Tcl_Obj* array, map<string,string>& m)
{
    string script = "array get ";     // tcl script to get element names
    script += Tcl_GetString(array);

    // run the script and get the result as a list object
#if TCL_MAJOR_VERSION < 8 || (TCL_MAJOR_VERSION==8 && TCL_MINOR_VERSION < 4)
    Tcl_Eval(interp, (char*) script.c_str());
#else
    Tcl_Eval(interp, script.c_str());
#endif
    Tcl_Obj* list_obj = Tcl_GetObjResult(interp);

    // get element names in an objest list
    int num_elts;       // number of elemtnts
    Tcl_Obj** elts;     // serialized array
    if (Tcl_ListObjGetElements(interp,list_obj,&num_elts,&elts) == TCL_ERROR) {
        Tcl_FreeResult(interp);
        throw string("failed to access an array");
    }

    // set the result map
    m.clear();
    for (int i=0; i < num_elts; i+=2) {
        m[Tcl_GetString(elts[i])] = Tcl_GetString(elts[i+1]);
    }

    Tcl_FreeResult(interp);
}

bool
check_array(Tcl_Interp* interp, Tcl_Obj* obj)
{
    string script = "array exist ";
    script += Tcl_GetString(obj);
#if TCL_MAJOR_VERSION < 8 || (TCL_MAJOR_VERSION==8 && TCL_MINOR_VERSION < 4)
    Tcl_Eval(interp, (char*) script.c_str());
#else
    Tcl_Eval(interp, script.c_str());
#endif
    return (strcmp(Tcl_GetStringResult(interp),"1")==0) ? true : false;
}


#include <ag/agtree.h>

#ifdef __cplusplus
extern "C" {
#endif
static int
_wrap_CreateAGSet(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::CreateAGSetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = CreateAGSet(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_ExistsAGSet(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::ExistsAGSetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = (bool)ExistsAGSet(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_DeleteAGSet(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::DeleteAGSetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            DeleteAGSet(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CreateAG(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::CreateAGstring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            result = CreateAG(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_ExistsAG(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::ExistsAGstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = (bool)ExistsAG(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_DeleteAG(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::DeleteAGstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            DeleteAG(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAGIds(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAGIdsstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAGIds(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CreateTimeline(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::CreateTimelinestring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = CreateTimeline(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_ExistsTimeline(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::ExistsTimelinestring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = (bool)ExistsTimeline(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_DeleteTimeline(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::DeleteTimelinestring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            DeleteTimeline(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CreateSignal(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string arg3 ;
    string arg4 ;
    string arg5 ;
    string arg6 ;
    string arg7 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooooooo:AG::CreateSignalstring string string string string string string ",0,0,0,0,0,0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        (&arg4)->assign(Tcl_GetString(objv[4]));
    }
    {
        (&arg5)->assign(Tcl_GetString(objv[5]));
    }
    {
        (&arg6)->assign(Tcl_GetString(objv[6]));
    }
    {
        (&arg7)->assign(Tcl_GetString(objv[7]));
    }
    {
        try {
            result = CreateSignal(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_ExistsSignal(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::ExistsSignalstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = (bool)ExistsSignal(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_DeleteSignal(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::DeleteSignalstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            DeleteSignal(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetSignals(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetSignalsstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetSignals(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetSignalMimeClass(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetSignalMimeClassstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetSignalMimeClass(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetSignalMimeType(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetSignalMimeTypestring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetSignalMimeType(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetSignalEncoding(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetSignalEncodingstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetSignalEncoding(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetSignalXlinkType(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetSignalXlinkTypestring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetSignalXlinkType(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetSignalXlinkHref(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetSignalXlinkHrefstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetSignalXlinkHref(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetSignalUnit(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetSignalUnitstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetSignalUnit(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetSignalTrack(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetSignalTrackstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetSignalTrack(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CreateAnnotation(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string arg3 ;
    string arg4 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oooo:AG::CreateAnnotationstring string string string ",0,0,0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        (&arg4)->assign(Tcl_GetString(objv[4]));
    }
    {
        try {
            result = CreateAnnotation(arg1,arg2,arg3,arg4);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_ExistsAnnotation(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::ExistsAnnotationstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = (bool)ExistsAnnotation(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_DeleteAnnotation(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::DeleteAnnotationstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            DeleteAnnotation(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CopyAnnotation(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::CopyAnnotationstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = CopyAnnotation(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SplitAnnotation(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::SplitAnnotationstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = SplitAnnotation(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_NSplitAnnotation(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    short arg2 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oh:AG::NSplitAnnotationstring short ",0,&arg2) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = NSplitAnnotation(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationType(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAnnotationTypestring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnnotationType(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationInfo(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAnnotationInfostring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnnotationInfo(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetStartAnchor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetStartAnchorstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetStartAnchor(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetEndAnchor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetEndAnchorstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetEndAnchor(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SetStartAnchor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::SetStartAnchorstring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            SetStartAnchor(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SetEndAnchor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::SetEndAnchorstring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            SetEndAnchor(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetStartOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetStartOffsetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = (double)GetStartOffset(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetEndOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetEndOffsetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = (double)GetEndOffset(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SetStartOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:AG::SetStartOffsetstring double ",0,&arg2) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            SetStartOffset(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SetEndOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:AG::SetEndOffsetstring double ",0,&arg2) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            SetEndOffset(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationTypes(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAnnotationTypesstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnnotationTypes(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationFeatureNames__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string *arg2 = 0 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::GetAnnotationFeatureNamesstring string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = GetAnnotationFeatureNames(arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationFeatureNames__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAnnotationFeatureNamesstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnnotationFeatureNames(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationFeatureNames(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_GetAnnotationFeatureNames__SWIG_1(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_GetAnnotationFeatureNames__SWIG_0(clientData, interp, objc, objv);
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'GetAnnotationFeatureNames'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_SetFeature(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string arg3 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::SetFeaturestring string string ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        try {
            SetFeature(arg1,arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_ExistsFeature(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::ExistsFeaturestring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            result = (bool)ExistsFeature(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_DeleteFeature(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::DeleteFeaturestring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            DeleteFeature(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetFeature(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::GetFeaturestring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            result = GetFeature(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_UnsetFeature(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::UnsetFeaturestring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            UnsetFeature(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetFeatureNames(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetFeatureNamesstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetFeatureNames(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SetFeatures(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    map<string,string > *arg2 = 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::SetFeaturesstring map<string,string > & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        static map<string,string> m;
        try {
            array2map(interp, objv[2], m);
            arg2 = &m;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        try {
            SetFeatures(arg1,*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetFeatures(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    map<string,string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetFeaturesstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetFeatures(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_UnsetVar(interp, "__tcl_ag_wrapper_temp__", 0);
        for (map<string,string>::iterator pos=(&result)->begin(); pos!=(&result)->end(); ++pos) {
            Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp),
            Tcl_NewStringObj(pos->first.c_str(),
            pos->first.size()));
            Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp),
            Tcl_NewStringObj(pos->second.c_str(),
            pos->second.size()));
        }
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_UnsetFeatures(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::UnsetFeaturesstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            UnsetFeatures(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CreateAnchor__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    string arg3 ;
    set<string > *arg4 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"odoo:AG::CreateAnchorstring double string set<string > & ",0,&arg2,0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        static set<string> s;
        try {
            tlist2set(interp, objv[4], s);
            arg4 = &s;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        try {
            result = CreateAnchor(arg1,arg2,arg3,*arg4);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CreateAnchor__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    set<string > *arg2 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::CreateAnchorstring set<string > & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        static set<string> s;
        try {
            tlist2set(interp, objv[2], s);
            arg2 = &s;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        try {
            result = CreateAnchor(arg1,*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CreateAnchor__SWIG_2(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::CreateAnchorstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = CreateAnchor(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CreateAnchor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_CreateAnchor__SWIG_2(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_CreateAnchor__SWIG_1(clientData, interp, objc, objv);
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                double tmp;
                if (Tcl_GetDoubleFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    {
                        void *ptr;
                        if (false) {
                            _v = 0;
                        }else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        return _wrap_CreateAnchor__SWIG_0(clientData, interp, objc, objv);
                    }
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'CreateAnchor'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_ExistsAnchor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::ExistsAnchorstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = (bool)ExistsAnchor(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_DeleteAnchor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::DeleteAnchorstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            DeleteAnchor(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SetAnchorOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:AG::SetAnchorOffsetstring double ",0,&arg2) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            SetAnchorOffset(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnchorOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAnchorOffsetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = (double)GetAnchorOffset(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SetOffsetUnit(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::SetOffsetUnitstring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            SetOffsetUnit(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetOffsetUnit(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetOffsetUnitstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetOffsetUnit(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SetAnchorSignalIds(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    set<string > *arg2 = 0 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::SetAnchorSignalIdsstring set<string > & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        static set<string> s;
        try {
            tlist2set(interp, objv[2], s);
            arg2 = &s;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        try {
            SetAnchorSignalIds(arg1,*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnchorSignalIds(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAnchorSignalIdsstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnchorSignalIds(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnchored(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAnchoredstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = (bool)GetAnchored(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_UnsetAnchorOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::UnsetAnchorOffsetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            UnsetAnchorOffset(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_SplitAnchor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::SplitAnchorstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = SplitAnchor(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetIncomingAnnotationSet__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string *arg2 = 0 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::GetIncomingAnnotationSetstring string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = GetIncomingAnnotationSet(arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetIncomingAnnotationSet__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetIncomingAnnotationSetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetIncomingAnnotationSet(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetIncomingAnnotationSet(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_GetIncomingAnnotationSet__SWIG_1(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_GetIncomingAnnotationSet__SWIG_0(clientData, interp, objc, objv);
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'GetIncomingAnnotationSet'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_GetOutgoingAnnotationSet__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string *arg2 = 0 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::GetOutgoingAnnotationSetstring string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = GetOutgoingAnnotationSet(arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetOutgoingAnnotationSet__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetOutgoingAnnotationSetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetOutgoingAnnotationSet(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetOutgoingAnnotationSet(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_GetOutgoingAnnotationSet__SWIG_1(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_GetOutgoingAnnotationSet__SWIG_0(clientData, interp, objc, objv);
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'GetOutgoingAnnotationSet'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_GetAnchorSet(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAnchorSetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnchorSet(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnchorSetByOffset__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    double arg3 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"odd:AG::GetAnchorSetByOffsetstring double double ",0,&arg2,&arg3) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnchorSetByOffset(arg1,arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnchorSetByOffset__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:AG::GetAnchorSetByOffsetstring double ",0,&arg2) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnchorSetByOffset(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnchorSetByOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                double tmp;
                if (Tcl_GetDoubleFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                return _wrap_GetAnchorSetByOffset__SWIG_1(clientData, interp, objc, objv);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                double tmp;
                if (Tcl_GetDoubleFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                {
                    double tmp;
                    if (Tcl_GetDoubleFromObj(NULL,argv[2],&tmp) == TCL_ERROR) _v = 0;
                    else _v = 1;
                }
                if (_v) {
                    return _wrap_GetAnchorSetByOffset__SWIG_0(clientData, interp, objc, objv);
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'GetAnchorSetByOffset'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_GetAnchorSetNearestOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:AG::GetAnchorSetNearestOffsetstring double ",0,&arg2) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnchorSetNearestOffset(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSet__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::GetAnnotationSetstring const & string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = GetAnnotationSet((string const &)*arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSet__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAnnotationSetstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = GetAnnotationSet((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSet(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_GetAnnotationSet__SWIG_1(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_GetAnnotationSet__SWIG_0(clientData, interp, objc, objv);
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'GetAnnotationSet'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSetByFeature__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string arg3 ;
    string *arg4 = 0 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oooo:AG::GetAnnotationSetByFeaturestring string string string const & ",0,0,0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[4]));
        arg4 = &s;
    }
    {
        try {
            result = GetAnnotationSetByFeature(arg1,arg2,arg3,(string const &)*arg4);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSetByFeature__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string arg3 ;
    set<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::GetAnnotationSetByFeaturestring string string ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        try {
            result = GetAnnotationSetByFeature(arg1,arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        set<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSetByFeature(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_GetAnnotationSetByFeature__SWIG_1(clientData, interp, objc, objv);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    {
                        void *ptr;
                        if (false) {
                            _v = 0;
                        }else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        return _wrap_GetAnnotationSetByFeature__SWIG_0(clientData, interp, objc, objv);
                    }
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'GetAnnotationSetByFeature'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSetByOffset__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    string *arg3 = 0 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"odo:AG::GetAnnotationSetByOffsetstring double string const & ",0,&arg2,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[3]));
        arg3 = &s;
    }
    {
        try {
            result = GetAnnotationSetByOffset(arg1,arg2,(string const &)*arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSetByOffset__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:AG::GetAnnotationSetByOffsetstring double ",0,&arg2) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnnotationSetByOffset(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSetByOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                double tmp;
                if (Tcl_GetDoubleFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                return _wrap_GetAnnotationSetByOffset__SWIG_1(clientData, interp, objc, objv);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                double tmp;
                if (Tcl_GetDoubleFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_GetAnnotationSetByOffset__SWIG_0(clientData, interp, objc, objv);
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'GetAnnotationSetByOffset'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSeqByOffset__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    double arg3 ;
    string *arg4 = 0 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oddo:AG::GetAnnotationSeqByOffsetstring double double string const & ",0,&arg2,&arg3,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[4]));
        arg4 = &s;
    }
    {
        try {
            result = GetAnnotationSeqByOffset(arg1,arg2,arg3,(string const &)*arg4);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSeqByOffset__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    double arg3 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"odd:AG::GetAnnotationSeqByOffsetstring double double ",0,&arg2,&arg3) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnnotationSeqByOffset(arg1,arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSeqByOffset__SWIG_2(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:AG::GetAnnotationSeqByOffsetstring double ",0,&arg2) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnnotationSeqByOffset(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSeqByOffset__SWIG_3(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAnnotationSeqByOffsetstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnnotationSeqByOffset(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationSeqByOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_GetAnnotationSeqByOffset__SWIG_3(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                double tmp;
                if (Tcl_GetDoubleFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                return _wrap_GetAnnotationSeqByOffset__SWIG_2(clientData, interp, objc, objv);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                double tmp;
                if (Tcl_GetDoubleFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                {
                    double tmp;
                    if (Tcl_GetDoubleFromObj(NULL,argv[2],&tmp) == TCL_ERROR) _v = 0;
                    else _v = 1;
                }
                if (_v) {
                    return _wrap_GetAnnotationSeqByOffset__SWIG_1(clientData, interp, objc, objv);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                double tmp;
                if (Tcl_GetDoubleFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                {
                    double tmp;
                    if (Tcl_GetDoubleFromObj(NULL,argv[2],&tmp) == TCL_ERROR) _v = 0;
                    else _v = 1;
                }
                if (_v) {
                    {
                        void *ptr;
                        if (false) {
                            _v = 0;
                        }else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        return _wrap_GetAnnotationSeqByOffset__SWIG_0(clientData, interp, objc, objv);
                    }
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'GetAnnotationSeqByOffset'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationByOffset__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    string *arg3 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"odo:AG::GetAnnotationByOffsetstring double string const & ",0,&arg2,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[3]));
        arg3 = &s;
    }
    {
        try {
            result = GetAnnotationByOffset(arg1,arg2,(string const &)*arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationByOffset__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    double arg2 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"od:AG::GetAnnotationByOffsetstring double ",0,&arg2) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAnnotationByOffset(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAnnotationByOffset(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                double tmp;
                if (Tcl_GetDoubleFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                return _wrap_GetAnnotationByOffset__SWIG_1(clientData, interp, objc, objv);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                double tmp;
                if (Tcl_GetDoubleFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_GetAnnotationByOffset__SWIG_0(clientData, interp, objc, objv);
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'GetAnnotationByOffset'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_GetAGSetId__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAGSetIdstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAGSetId(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAGSetId__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,":AG::GetAGSetId") == TCL_ERROR) SWIG_fail;
    {
        try {
            result = GetAGSetId();
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetAGSetId(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 0) {
        return _wrap_GetAGSetId__SWIG_1(clientData, interp, objc, objv);
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_GetAGSetId__SWIG_0(clientData, interp, objc, objv);
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'GetAGSetId'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_GetAGId(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetAGIdstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetAGId(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_GetTimelineId(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::GetTimelineIdstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = GetTimelineId(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_toXML(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::toXMLstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = toXML(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}



#ifdef AGDB

static int
_wrap_LoadFromDB(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::LoadFromDBstring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            result = (bool)LoadFromDB(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_StoreToDB(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::StoreToDBstring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            result = (bool)StoreToDB(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_StoreSQLs(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::StoreSQLsstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = StoreSQLs(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}



#endif

static int
_wrap_SPrecedes(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::SPrecedesstring const & string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = (bool)SPrecedes((string const &)*arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Load__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string *arg3 = 0 ;
    map<string,string > *arg4 = (map<string,string > *) 0 ;
    map<string,string > *arg5 = (map<string,string > *) 0 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooooo:AG::Loadstring const & string const & string const & map<string,string > * map<string,string > * ",0,0,0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[3]));
        arg3 = &s;
    }
    {
        static map<string,string> m;
        try {
            array2map(interp, objv[4], m);
            arg4 = &m;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        static map<string,string> m;
        try {
            array2map(interp, objv[5], m);
            arg5 = &m;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        try {
            result = Load((string const &)*arg1,(string const &)*arg2,(string const &)*arg3,arg4,arg5);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Load__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string *arg3 = 0 ;
    map<string,string > *arg4 = (map<string,string > *) 0 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oooo:AG::Loadstring const & string const & string const & map<string,string > * ",0,0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[3]));
        arg3 = &s;
    }
    {
        static map<string,string> m;
        try {
            array2map(interp, objv[4], m);
            arg4 = &m;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        try {
            result = Load((string const &)*arg1,(string const &)*arg2,(string const &)*arg3,arg4);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Load__SWIG_2(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string *arg3 = 0 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::Loadstring const & string const & string const & ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[3]));
        arg3 = &s;
    }
    {
        try {
            result = Load((string const &)*arg1,(string const &)*arg2,(string const &)*arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Load__SWIG_3(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::Loadstring const & string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = Load((string const &)*arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Load(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_Load__SWIG_3(clientData, interp, objc, objv);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_Load__SWIG_2(clientData, interp, objc, objv);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    {
                        void *ptr;
                        if (!check_array(interp, argv[3])) {
                            _v = 0;
                        }else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        return _wrap_Load__SWIG_1(clientData, interp, objc, objv);
                    }
                }
            }
        }
    }
    if (argc == 5) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    {
                        void *ptr;
                        if (!check_array(interp, argv[3])) {
                            _v = 0;
                        }else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        {
                            void *ptr;
                            if (!check_array(interp, argv[4])) {
                                _v = 0;
                            }else {
                                _v = 1;
                            }
                        }
                        if (_v) {
                            return _wrap_Load__SWIG_0(clientData, interp, objc, objv);
                        }
                    }
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Load'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_Store__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string *arg3 = 0 ;
    map<string,string > *arg4 = (map<string,string > *) 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oooo:AG::Storestring const & string const & string const & map<string,string > * ",0,0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[3]));
        arg3 = &s;
    }
    {
        static map<string,string> m;
        try {
            array2map(interp, objv[4], m);
            arg4 = &m;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        try {
            result = Store((string const &)*arg1,(string const &)*arg2,(string const &)*arg3,arg4);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Store__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string *arg3 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::Storestring const & string const & string const & ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[3]));
        arg3 = &s;
    }
    {
        try {
            result = Store((string const &)*arg1,(string const &)*arg2,(string const &)*arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Store(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_Store__SWIG_1(clientData, interp, objc, objv);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    {
                        void *ptr;
                        if (!check_array(interp, argv[3])) {
                            _v = 0;
                        }else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        return _wrap_Store__SWIG_0(clientData, interp, objc, objv);
                    }
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Store'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_Store2__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    list<string > *arg3 = (list<string > *) (list<string > *)0 ;
    map<string,string > *arg4 = (map<string,string > *) 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oooo:AG::Store2string const & string const & list<string > *const map<string,string > * ",0,0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        static list<string> l;
        try {
            tlist2list(interp, objv[3], l);
            arg3 = &l;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        static map<string,string> m;
        try {
            array2map(interp, objv[4], m);
            arg4 = &m;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        try {
            result = Store2((string const &)*arg1,(string const &)*arg2,arg3,arg4);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Store2__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    list<string > *arg3 = (list<string > *) (list<string > *)0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::Store2string const & string const & list<string > *const ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        static list<string> l;
        try {
            tlist2list(interp, objv[3], l);
            arg3 = &l;
        }
        catch (const string& msg) {
            raise_error(msg);
        }
    }
    {
        try {
            result = Store2((string const &)*arg1,(string const &)*arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_Store2(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_Store2__SWIG_1(clientData, interp, objc, objv);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    {
                        void *ptr;
                        if (!check_array(interp, argv[3])) {
                            _v = 0;
                        }else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        return _wrap_Store2__SWIG_0(clientData, interp, objc, objv);
                    }
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'Store2'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_CheckAnchorOffsetTotal(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::CheckAnchorOffsetTotalstring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            result = (bool)CheckAnchorOffsetTotal(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CheckAnchorOffsetBounded(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::CheckAnchorOffsetBoundedstring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            result = (bool)CheckAnchorOffsetBounded(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CheckFeatureExists(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string arg3 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::CheckFeatureExistsstring string string ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        try {
            result = (bool)CheckFeatureExists(arg1,arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CheckFeatureIsAnnotationId(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string arg3 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::CheckFeatureIsAnnotationIdstring string string ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        try {
            result = (bool)CheckFeatureIsAnnotationId(arg1,arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CheckLinear(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::CheckLinearstring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            result = (bool)CheckLinear(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CheckConnected(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::CheckConnectedstring string ",0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        try {
            result = (bool)CheckConnected(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CheckCoextensive(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string arg3 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::CheckCoextensivestring string string ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        try {
            result = (bool)CheckCoextensive(arg1,arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_CheckSpan(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string arg2 ;
    string arg3 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::CheckSpanstring string string ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        (&arg2)->assign(Tcl_GetString(objv[2]));
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        try {
            result = (bool)CheckSpan(arg1,arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_init_tree__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::tree_init_treestring const & string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = tree_init_tree((string const &)*arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_init_tree__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_init_treestring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = tree_init_tree((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_init_tree(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_tree_init_tree__SWIG_1(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_tree_init_tree__SWIG_0(clientData, interp, objc, objv);
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'tree_init_tree'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_tree_move_down__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string arg3 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::tree_move_downstring const & string const & new_anno ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        try {
            result = (bool)tree_move_down((string const &)*arg1,(string const &)*arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_move_down__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::tree_move_downstring const & string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = (bool)tree_move_down((string const &)*arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_move_down__SWIG_2(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_move_downstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = (bool)tree_move_down((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_move_down(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_tree_move_down__SWIG_2(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_tree_move_down__SWIG_1(clientData, interp, objc, objv);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_tree_move_down__SWIG_0(clientData, interp, objc, objv);
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'tree_move_down'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_tree_move_up(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_move_upstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = (bool)tree_move_up((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_promote_right(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_promote_rightstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = (bool)tree_promote_right((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_promote_left(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_promote_leftstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = (bool)tree_promote_left((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_demote_right(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_demote_rightstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = (bool)tree_demote_right((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_demote_left(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_demote_leftstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = (bool)tree_demote_left((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_first_tree(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_first_treestring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = tree_first_tree((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_last_tree(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_last_treestring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = tree_last_tree((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_move(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::tree_movestring const & string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = (bool)tree_move((string const &)*arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node_left__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string arg3 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::tree_insert_node_leftstring const & string const & string ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        try {
            result = tree_insert_node_left((string const &)*arg1,(string const &)*arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node_left__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::tree_insert_node_leftstring const & string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = tree_insert_node_left((string const &)*arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node_left__SWIG_2(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_insert_node_leftstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = tree_insert_node_left((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node_left(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_tree_insert_node_left__SWIG_2(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_tree_insert_node_left__SWIG_1(clientData, interp, objc, objv);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_tree_insert_node_left__SWIG_0(clientData, interp, objc, objv);
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'tree_insert_node_left'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node_right__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string arg3 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::tree_insert_node_rightstring const & string const & string ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        (&arg3)->assign(Tcl_GetString(objv[3]));
    }
    {
        try {
            result = tree_insert_node_right((string const &)*arg1,(string const &)*arg2,arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node_right__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::tree_insert_node_rightstring const & string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = tree_insert_node_right((string const &)*arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node_right__SWIG_2(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_insert_node_rightstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = tree_insert_node_right((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node_right(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_tree_insert_node_right__SWIG_2(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_tree_insert_node_right__SWIG_1(clientData, interp, objc, objv);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_tree_insert_node_right__SWIG_0(clientData, interp, objc, objv);
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'tree_insert_node_right'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_tree_delete_node_left(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_delete_node_leftstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = (bool)tree_delete_node_left((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_delete_node_right(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_delete_node_rightstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = (bool)tree_delete_node_right((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_root__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    int arg2 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oi:AG::tree_rootstring int ",0,&arg2) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = tree_root(arg1,arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_root__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_rootstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = tree_root(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_root(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            return _wrap_tree_root__SWIG_1(clientData, interp, objc, objv);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                long tmp;
                if (Tcl_GetLongFromObj(NULL,argv[1],&tmp) == TCL_ERROR) _v = 0;
                else _v = 1;
            }
            if (_v) {
                return _wrap_tree_root__SWIG_0(clientData, interp, objc, objv);
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'tree_root'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_tree_parent(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_parentstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = tree_parent((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_children(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_childrenstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = tree_children((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_left(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_leftstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = tree_left((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_right(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_rightstring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = tree_right((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_path(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string arg1 ;
    list<string > result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_pathstring ",0) == TCL_ERROR) SWIG_fail;
    {
        (&arg1)->assign(Tcl_GetString(objv[1]));
    }
    {
        try {
            result = tree_path(arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        list<string>::iterator pos = (&result)->begin();
        for (int i=0; pos != (&result)->end(); ++i, ++pos)
        Tcl_ListObjAppendElement
        (interp, Tcl_GetObjResult(interp), Tcl_NewStringObj(pos->c_str(), pos->size()));
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_common_ancestor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::tree_common_ancestorstring const & string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = tree_common_ancestor((string const &)*arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node__SWIG_0(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string *arg3 = 0 ;
    string *arg4 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oooo:AG::tree_insert_nodestring const & string const & string const & string const & ",0,0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[3]));
        arg3 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[4]));
        arg4 = &s;
    }
    {
        try {
            result = tree_insert_node((string const &)*arg1,(string const &)*arg2,(string const &)*arg3,(string const &)*arg4);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node__SWIG_1(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string *arg3 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"ooo:AG::tree_insert_nodestring const & string const & string const & ",0,0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[3]));
        arg3 = &s;
    }
    {
        try {
            result = tree_insert_node((string const &)*arg1,(string const &)*arg2,(string const &)*arg3);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node__SWIG_2(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    string *arg2 = 0 ;
    string result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:AG::tree_insert_nodestring const & string const & ",0,0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        static string s;
        s.assign(Tcl_GetString(objv[2]));
        arg2 = &s;
    }
    {
        try {
            result = tree_insert_node((string const &)*arg1,(string const &)*arg2);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), (char*) (&result)->c_str(), (&result)->size());
        
        
        
    }
    return TCL_OK;
    fail:
    return TCL_ERROR;
}


static int
_wrap_tree_insert_node(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    Tcl_Obj *CONST *argv = objv+1;
    int argc = objc-1;
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                return _wrap_tree_insert_node__SWIG_2(clientData, interp, objc, objv);
            }
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    return _wrap_tree_insert_node__SWIG_1(clientData, interp, objc, objv);
                }
            }
        }
    }
    if (argc == 4) {
        int _v;
        {
            void *ptr;
            if (false) {
                _v = 0;
            }else {
                _v = 1;
            }
        }
        if (_v) {
            {
                void *ptr;
                if (false) {
                    _v = 0;
                }else {
                    _v = 1;
                }
            }
            if (_v) {
                {
                    void *ptr;
                    if (false) {
                        _v = 0;
                    }else {
                        _v = 1;
                    }
                }
                if (_v) {
                    {
                        void *ptr;
                        if (false) {
                            _v = 0;
                        }else {
                            _v = 1;
                        }
                    }
                    if (_v) {
                        return _wrap_tree_insert_node__SWIG_0(clientData, interp, objc, objv);
                    }
                }
            }
        }
    }
    
    Tcl_SetResult(interp,(char *) "No matching function for overloaded 'tree_insert_node'", TCL_STATIC);
    return TCL_ERROR;
}


static int
_wrap_tree_delete_node(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    string *arg1 = 0 ;
    bool result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:AG::tree_delete_nodestring const & ",0) == TCL_ERROR) SWIG_fail;
    {
        static string s;
        s.assign(Tcl_GetString(objv[1]));
        arg1 = &s;
    }
    {
        try {
            result = (bool)tree_delete_node((string const &)*arg1);
            
        }
        catch (AGException& err) {
            string message = "AGException\x01";
            message += err.error();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::LoadError& err) {
            string message = "LoadError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
        catch (const agfio::StoreError& err) {
            string message = "StoreError\x01";
            message += err.what();
            SWIG_exception(SWIG_RuntimeError, (char*) message.c_str());
        }
    }
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
    fail:
    return TCL_ERROR;
}



static swig_command_info swig_commands[] = {
    { SWIG_prefix "CreateAGSet", (swig_wrapper_func) _wrap_CreateAGSet, NULL},
    { SWIG_prefix "ExistsAGSet", (swig_wrapper_func) _wrap_ExistsAGSet, NULL},
    { SWIG_prefix "DeleteAGSet", (swig_wrapper_func) _wrap_DeleteAGSet, NULL},
    { SWIG_prefix "CreateAG", (swig_wrapper_func) _wrap_CreateAG, NULL},
    { SWIG_prefix "ExistsAG", (swig_wrapper_func) _wrap_ExistsAG, NULL},
    { SWIG_prefix "DeleteAG", (swig_wrapper_func) _wrap_DeleteAG, NULL},
    { SWIG_prefix "GetAGIds", (swig_wrapper_func) _wrap_GetAGIds, NULL},
    { SWIG_prefix "CreateTimeline", (swig_wrapper_func) _wrap_CreateTimeline, NULL},
    { SWIG_prefix "ExistsTimeline", (swig_wrapper_func) _wrap_ExistsTimeline, NULL},
    { SWIG_prefix "DeleteTimeline", (swig_wrapper_func) _wrap_DeleteTimeline, NULL},
    { SWIG_prefix "CreateSignal", (swig_wrapper_func) _wrap_CreateSignal, NULL},
    { SWIG_prefix "ExistsSignal", (swig_wrapper_func) _wrap_ExistsSignal, NULL},
    { SWIG_prefix "DeleteSignal", (swig_wrapper_func) _wrap_DeleteSignal, NULL},
    { SWIG_prefix "GetSignals", (swig_wrapper_func) _wrap_GetSignals, NULL},
    { SWIG_prefix "GetSignalMimeClass", (swig_wrapper_func) _wrap_GetSignalMimeClass, NULL},
    { SWIG_prefix "GetSignalMimeType", (swig_wrapper_func) _wrap_GetSignalMimeType, NULL},
    { SWIG_prefix "GetSignalEncoding", (swig_wrapper_func) _wrap_GetSignalEncoding, NULL},
    { SWIG_prefix "GetSignalXlinkType", (swig_wrapper_func) _wrap_GetSignalXlinkType, NULL},
    { SWIG_prefix "GetSignalXlinkHref", (swig_wrapper_func) _wrap_GetSignalXlinkHref, NULL},
    { SWIG_prefix "GetSignalUnit", (swig_wrapper_func) _wrap_GetSignalUnit, NULL},
    { SWIG_prefix "GetSignalTrack", (swig_wrapper_func) _wrap_GetSignalTrack, NULL},
    { SWIG_prefix "CreateAnnotation", (swig_wrapper_func) _wrap_CreateAnnotation, NULL},
    { SWIG_prefix "ExistsAnnotation", (swig_wrapper_func) _wrap_ExistsAnnotation, NULL},
    { SWIG_prefix "DeleteAnnotation", (swig_wrapper_func) _wrap_DeleteAnnotation, NULL},
    { SWIG_prefix "CopyAnnotation", (swig_wrapper_func) _wrap_CopyAnnotation, NULL},
    { SWIG_prefix "SplitAnnotation", (swig_wrapper_func) _wrap_SplitAnnotation, NULL},
    { SWIG_prefix "NSplitAnnotation", (swig_wrapper_func) _wrap_NSplitAnnotation, NULL},
    { SWIG_prefix "GetAnnotationType", (swig_wrapper_func) _wrap_GetAnnotationType, NULL},
    { SWIG_prefix "GetAnnotationInfo", (swig_wrapper_func) _wrap_GetAnnotationInfo, NULL},
    { SWIG_prefix "GetStartAnchor", (swig_wrapper_func) _wrap_GetStartAnchor, NULL},
    { SWIG_prefix "GetEndAnchor", (swig_wrapper_func) _wrap_GetEndAnchor, NULL},
    { SWIG_prefix "SetStartAnchor", (swig_wrapper_func) _wrap_SetStartAnchor, NULL},
    { SWIG_prefix "SetEndAnchor", (swig_wrapper_func) _wrap_SetEndAnchor, NULL},
    { SWIG_prefix "GetStartOffset", (swig_wrapper_func) _wrap_GetStartOffset, NULL},
    { SWIG_prefix "GetEndOffset", (swig_wrapper_func) _wrap_GetEndOffset, NULL},
    { SWIG_prefix "SetStartOffset", (swig_wrapper_func) _wrap_SetStartOffset, NULL},
    { SWIG_prefix "SetEndOffset", (swig_wrapper_func) _wrap_SetEndOffset, NULL},
    { SWIG_prefix "GetAnnotationTypes", (swig_wrapper_func) _wrap_GetAnnotationTypes, NULL},
    { SWIG_prefix "GetAnnotationFeatureNames", (swig_wrapper_func) _wrap_GetAnnotationFeatureNames, NULL},
    { SWIG_prefix "SetFeature", (swig_wrapper_func) _wrap_SetFeature, NULL},
    { SWIG_prefix "ExistsFeature", (swig_wrapper_func) _wrap_ExistsFeature, NULL},
    { SWIG_prefix "DeleteFeature", (swig_wrapper_func) _wrap_DeleteFeature, NULL},
    { SWIG_prefix "GetFeature", (swig_wrapper_func) _wrap_GetFeature, NULL},
    { SWIG_prefix "UnsetFeature", (swig_wrapper_func) _wrap_UnsetFeature, NULL},
    { SWIG_prefix "GetFeatureNames", (swig_wrapper_func) _wrap_GetFeatureNames, NULL},
    { SWIG_prefix "SetFeatures", (swig_wrapper_func) _wrap_SetFeatures, NULL},
    { SWIG_prefix "GetFeatures", (swig_wrapper_func) _wrap_GetFeatures, NULL},
    { SWIG_prefix "UnsetFeatures", (swig_wrapper_func) _wrap_UnsetFeatures, NULL},
    { SWIG_prefix "CreateAnchor", (swig_wrapper_func) _wrap_CreateAnchor, NULL},
    { SWIG_prefix "ExistsAnchor", (swig_wrapper_func) _wrap_ExistsAnchor, NULL},
    { SWIG_prefix "DeleteAnchor", (swig_wrapper_func) _wrap_DeleteAnchor, NULL},
    { SWIG_prefix "SetAnchorOffset", (swig_wrapper_func) _wrap_SetAnchorOffset, NULL},
    { SWIG_prefix "GetAnchorOffset", (swig_wrapper_func) _wrap_GetAnchorOffset, NULL},
    { SWIG_prefix "SetOffsetUnit", (swig_wrapper_func) _wrap_SetOffsetUnit, NULL},
    { SWIG_prefix "GetOffsetUnit", (swig_wrapper_func) _wrap_GetOffsetUnit, NULL},
    { SWIG_prefix "SetAnchorSignalIds", (swig_wrapper_func) _wrap_SetAnchorSignalIds, NULL},
    { SWIG_prefix "GetAnchorSignalIds", (swig_wrapper_func) _wrap_GetAnchorSignalIds, NULL},
    { SWIG_prefix "GetAnchored", (swig_wrapper_func) _wrap_GetAnchored, NULL},
    { SWIG_prefix "UnsetAnchorOffset", (swig_wrapper_func) _wrap_UnsetAnchorOffset, NULL},
    { SWIG_prefix "SplitAnchor", (swig_wrapper_func) _wrap_SplitAnchor, NULL},
    { SWIG_prefix "GetIncomingAnnotationSet", (swig_wrapper_func) _wrap_GetIncomingAnnotationSet, NULL},
    { SWIG_prefix "GetOutgoingAnnotationSet", (swig_wrapper_func) _wrap_GetOutgoingAnnotationSet, NULL},
    { SWIG_prefix "GetAnchorSet", (swig_wrapper_func) _wrap_GetAnchorSet, NULL},
    { SWIG_prefix "GetAnchorSetByOffset", (swig_wrapper_func) _wrap_GetAnchorSetByOffset, NULL},
    { SWIG_prefix "GetAnchorSetNearestOffset", (swig_wrapper_func) _wrap_GetAnchorSetNearestOffset, NULL},
    { SWIG_prefix "GetAnnotationSet", (swig_wrapper_func) _wrap_GetAnnotationSet, NULL},
    { SWIG_prefix "GetAnnotationSetByFeature", (swig_wrapper_func) _wrap_GetAnnotationSetByFeature, NULL},
    { SWIG_prefix "GetAnnotationSetByOffset", (swig_wrapper_func) _wrap_GetAnnotationSetByOffset, NULL},
    { SWIG_prefix "GetAnnotationSeqByOffset", (swig_wrapper_func) _wrap_GetAnnotationSeqByOffset, NULL},
    { SWIG_prefix "GetAnnotationByOffset", (swig_wrapper_func) _wrap_GetAnnotationByOffset, NULL},
    { SWIG_prefix "GetAGSetId", (swig_wrapper_func) _wrap_GetAGSetId, NULL},
    { SWIG_prefix "GetAGId", (swig_wrapper_func) _wrap_GetAGId, NULL},
    { SWIG_prefix "GetTimelineId", (swig_wrapper_func) _wrap_GetTimelineId, NULL},
    { SWIG_prefix "toXML", (swig_wrapper_func) _wrap_toXML, NULL},
#ifdef AGDB
    { SWIG_prefix "LoadFromDB", (swig_wrapper_func) _wrap_LoadFromDB, NULL},
    { SWIG_prefix "StoreToDB", (swig_wrapper_func) _wrap_StoreToDB, NULL},
    { SWIG_prefix "StoreSQLs", (swig_wrapper_func) _wrap_StoreSQLs, NULL},
#endif
    { SWIG_prefix "SPrecedes", (swig_wrapper_func) _wrap_SPrecedes, NULL},
    { SWIG_prefix "Load", (swig_wrapper_func) _wrap_Load, NULL},
    { SWIG_prefix "Store", (swig_wrapper_func) _wrap_Store, NULL},
    { SWIG_prefix "Store2", (swig_wrapper_func) _wrap_Store2, NULL},
    { SWIG_prefix "CheckAnchorOffsetTotal", (swig_wrapper_func) _wrap_CheckAnchorOffsetTotal, NULL},
    { SWIG_prefix "CheckAnchorOffsetBounded", (swig_wrapper_func) _wrap_CheckAnchorOffsetBounded, NULL},
    { SWIG_prefix "CheckFeatureExists", (swig_wrapper_func) _wrap_CheckFeatureExists, NULL},
    { SWIG_prefix "CheckFeatureIsAnnotationId", (swig_wrapper_func) _wrap_CheckFeatureIsAnnotationId, NULL},
    { SWIG_prefix "CheckLinear", (swig_wrapper_func) _wrap_CheckLinear, NULL},
    { SWIG_prefix "CheckConnected", (swig_wrapper_func) _wrap_CheckConnected, NULL},
    { SWIG_prefix "CheckCoextensive", (swig_wrapper_func) _wrap_CheckCoextensive, NULL},
    { SWIG_prefix "CheckSpan", (swig_wrapper_func) _wrap_CheckSpan, NULL},
    { SWIG_prefix "tree_init_tree", (swig_wrapper_func) _wrap_tree_init_tree, NULL},
    { SWIG_prefix "tree_move_down", (swig_wrapper_func) _wrap_tree_move_down, NULL},
    { SWIG_prefix "tree_move_up", (swig_wrapper_func) _wrap_tree_move_up, NULL},
    { SWIG_prefix "tree_promote_right", (swig_wrapper_func) _wrap_tree_promote_right, NULL},
    { SWIG_prefix "tree_promote_left", (swig_wrapper_func) _wrap_tree_promote_left, NULL},
    { SWIG_prefix "tree_demote_right", (swig_wrapper_func) _wrap_tree_demote_right, NULL},
    { SWIG_prefix "tree_demote_left", (swig_wrapper_func) _wrap_tree_demote_left, NULL},
    { SWIG_prefix "tree_first_tree", (swig_wrapper_func) _wrap_tree_first_tree, NULL},
    { SWIG_prefix "tree_last_tree", (swig_wrapper_func) _wrap_tree_last_tree, NULL},
    { SWIG_prefix "tree_move", (swig_wrapper_func) _wrap_tree_move, NULL},
    { SWIG_prefix "tree_insert_node_left", (swig_wrapper_func) _wrap_tree_insert_node_left, NULL},
    { SWIG_prefix "tree_insert_node_right", (swig_wrapper_func) _wrap_tree_insert_node_right, NULL},
    { SWIG_prefix "tree_delete_node_left", (swig_wrapper_func) _wrap_tree_delete_node_left, NULL},
    { SWIG_prefix "tree_delete_node_right", (swig_wrapper_func) _wrap_tree_delete_node_right, NULL},
    { SWIG_prefix "tree_root", (swig_wrapper_func) _wrap_tree_root, NULL},
    { SWIG_prefix "tree_parent", (swig_wrapper_func) _wrap_tree_parent, NULL},
    { SWIG_prefix "tree_children", (swig_wrapper_func) _wrap_tree_children, NULL},
    { SWIG_prefix "tree_left", (swig_wrapper_func) _wrap_tree_left, NULL},
    { SWIG_prefix "tree_right", (swig_wrapper_func) _wrap_tree_right, NULL},
    { SWIG_prefix "tree_path", (swig_wrapper_func) _wrap_tree_path, NULL},
    { SWIG_prefix "tree_common_ancestor", (swig_wrapper_func) _wrap_tree_common_ancestor, NULL},
    { SWIG_prefix "tree_insert_node", (swig_wrapper_func) _wrap_tree_insert_node, NULL},
    { SWIG_prefix "tree_delete_node", (swig_wrapper_func) _wrap_tree_delete_node, NULL},
    {0, 0, 0}
};

static swig_var_info swig_variables[] = {
    {0,0,0,0}
};

static swig_const_info swig_constants[] = {
    {0,0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_mapTstring_string_t[] = {{"_p_mapTstring_string_t", 0, "map<string,string > *", 0},{"_p_mapTstring_string_t"},{0}};
static swig_type_info _swigt__p_setTstring_t[] = {{"_p_setTstring_t", 0, "set<string > *", 0},{"_p_setTstring_t"},{0}};
static swig_type_info _swigt__p_listTstring_t[] = {{"_p_listTstring_t", 0, "list<string > *", 0},{"_p_listTstring_t"},{0}};
static swig_type_info _swigt__p_string[] = {{"_p_string", 0, "string *", 0},{"_p_string"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_mapTstring_string_t, 
_swigt__p_setTstring_t, 
_swigt__p_listTstring_t, 
_swigt__p_string, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

#ifdef __cplusplus
}
#endif

SWIGEXPORT(int) SWIG_init(Tcl_Interp *interp) {
    int i;
    static int _init = 0;
    if (interp == 0) return TCL_ERROR;
    #ifdef USE_TCL_STUBS
    if (Tcl_InitStubs(interp, (char*)"8.1", 0) == NULL) {
        return TCL_ERROR;
    }
    #endif
    
    Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
    
    #ifdef SWIG_namespace
    Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
    #endif
    if (!_init) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        _init = 1;
    }
    for (i = 0; swig_commands[i].name; i++) {
        Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper, swig_commands[i].clientdata, NULL);
    }
    for (i = 0; swig_variables[i].name; i++) {
        Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
        Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
        Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
    }
    SWIG_InstallConstants(interp, swig_constants);
    
    return TCL_OK;
}

